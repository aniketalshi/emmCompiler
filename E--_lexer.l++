%option noyywrap
%option never-interactive

%{
#include "E--_lexer.tab.h"
#include <iostream>
#include <limits.h>

using namespace std;

const char* yyfilename = "";
int yylinenum = 0;

unsigned int htoi(char *s) {
    unsigned int val = 0;
     
    if (*s == '0' && (*(s+1)=='x' || *(s+1)=='X')) s += 2;
     
    while (*s != '\0') {
        if (val > UINT_MAX) {
            return 0;
        } else if (*s >= '0' && *s <='9') {
            val = val * 16 + *s - '0';
        } else if (*s>='A' && *s <='F') {
            val = val * 16 + *s - 55;
        } else if (*s>='a' && *s <='f') {
            val = val * 16 + *s - 87; 
        } else {
            return 0;
        }
        s++;
    }

    return val;
}

char* checkStringConst(char *input) {
    char *output = (char*) malloc(strlen(input) + 1);
    int i, outlen = 0;

    while(input[i] != '\0') {
        char cursym = input[i];
        if (cursym == '\\') {
            cursym = input[++i];
            switch (cursym) {
               case 'n':
                    output[outlen++] = '\n';
                    break;
                case 'x':
                {
                    // This is always of the form '\xhh' or '\xHH'
                    if (input[i+1] && input[i+2]) {
                        char hexStr[3];
                        hexStr[0] = input[++i];
                        hexStr[1] = input[++i];
                        hexStr[2] = '\0';
                        output[outlen++] = htoi(hexStr);
                    }
                    break;
                }
                case 'r':
                    output[outlen++] = '\r';
                    break;
                case 't':
                    output[outlen++] = '\t';
                    break;
                case '\"':
                    output[outlen++] = '\"';
                    break;
                case '\\':
                    output[outlen++] = '\\';
                    break;
                default:
                    output[outlen++] = cursym;
            }
        } else {
            output[outlen++] = cursym;
        }
        i++;
    }
    output[outlen] = '\0';
    return output;
}

void updateLineFileInfo() {
    if (yytext[0] != '#' || yytext[1] != ' ')
        return;

    char *ptr = yytext+2;
    char *line, *fileName;

    line = ptr;
    while (*++ptr != ' ');
    *ptr++ = '\0';
    yylinenum = atoi(line);

    fileName = ptr;
    // Skip over first quote
    ptr++;
    while (*++ptr != '"');
    *ptr = '\0';

    // NOTE: For proper diff of given output files, using Relative Paths of filenames
    while(*ptr != '/' && ptr != fileName)  ptr--;
    yyfilename = ptr + 1;
}

%}

 /**************** Definitions ****************/

DECIMAL_DIGIT       [0-9] 
HEX_DIGIT           [0-9a-fA-F]

UINT_NUM            {DECIMAL_DIGIT}+
INT_NUM             ("+"|"-")?{UINT_NUM}
DECIMAL_NUM         {UINT_NUM}|{INT_NUM}
HEX_NUM		    "0"(X|x){HEX_DIGIT}+

EXPONENT            (E|e){INT_NUM}
DOUBLE_NUM          ({INT_NUM}"."{UINT_NUM}?|{INT_NUM}?"."{UINT_NUM}){EXPONENT}?|{INT_NUM}{EXPONENT}

ID                  [a-zA-Z_][a-zA-Z0-9_]*
STRCONST            "\""[^\n]*"\""
MULTI_LINE_STRING   "\""[^"\""^\n]*[^\n]?

INFO_LINES          "# "{UINT_NUM}" "{STRCONST}[^\n]*\n

WHITE_SPACES        [ \t]+
MULTI_LINE_COMMENT  "/*"[^"*/"]*"*/"
SINGLE_LINE_COMMENT "//"[^\n]*
COMMENTS            {MULTI_LINE_COMMENT}|{SINGLE_LINE_COMMENT}

%%

 /**************** Recognize operators ****************/

":"                 { return TOK_COLON; }
","                 { return TOK_COMMA; }
"."                 { return TOK_DOT; }
";"                 { return TOK_SEMICOLON; }
"["                 { return TOK_LBRACK; }
"]"                 { return TOK_RBRACK; }
"("                 { return TOK_LPAREN; }
")"                 { return TOK_RPAREN; }
"{"                 { return TOK_LBRACE; }
"}"                 { return TOK_RBRACE; }
"+"                 { return TOK_PLUS; }
"-"                 { return TOK_MINUS; }
"*"                 { return TOK_MULT; }
"/"                 { return TOK_DIV; }
"="                 { return TOK_ASSIGN; }
"&&"                { return TOK_AND; }
"||"                { return TOK_OR; }
"!"                 { return TOK_NOT; }
">"                 { return TOK_GT; }
"<"                 { return TOK_LT; }
"=="                { return TOK_EQ; }
"!="                { return TOK_NE; }
">="                { return TOK_GE; }
"<="                { return TOK_LE; }
"%"                 { return TOK_MOD; }
"->"	            { return TOK_ARROW; }
"?"	            { return TOK_QMARK; }
"&"                 { return TOK_BITAND; }
"|"                 { return TOK_BITOR; }
"~"                 { return TOK_BITNOT; }
"^"                 { return TOK_BITXOR; }
"\\/"               { return TOK_PAT_OR; }
"<<"                { return TOK_SHL; }
">>"                { return TOK_SHR; }

 /**************** Recognize reserved words ****************/

"interface"         { return TOK_INTERFACE; }
"import"            { return TOK_USE; }
"any"               { return TOK_ANY; }
"bit"               { return TOK_BIT; }
"byte"              { return TOK_BYTE; }
"bool"              { return TOK_BOOL; }
"double"            { return TOK_DOUBLE; }
"enum"              { return TOK_ENUM; }
"class"             { return TOK_CLASS; }
"event"             { return TOK_EVENT; }
"print"             { return TOK_PRINT; }
"else"              { return TOK_ELSE; }
"false"             { return TOK_FALSE; }
"if"                { return TOK_IF; }
"int"               { return TOK_INT; }
"string"            { return TOK_STRING; }
"return"            { return TOK_RETURN; }
"true"              { return TOK_TRUE; }
"void"              { return TOK_VOID; }

 /**************** Other MISC Rules ****************/

{ID}                {
                        yylval.cVal = yytext;
                        return TOK_ID;
                    }

{STRCONST}          {
                        // Skip "" from string literals
                        int len = yyleng;
                        yytext[len-1] = '\0';
                        yylval.cVal = checkStringConst(yytext+1);
                        return TOK_STRCONST;
                    }
                    
{MULTI_LINE_STRING} {
                        printf("String constant cannot span multiple lines\n");
                        yylval.cVal = checkStringConst(yytext+1);
                        return TOK_STRCONST;
                    }

{DOUBLE_NUM}        {
                        yylval.dVal = atof(yytext);
                        return TOK_DOUBLENUM;
                    }

{DECIMAL_NUM}       {
                        yylval.uVal = atoi(yytext);
                        return TOK_UINTNUM;
                    }

{HEX_NUM}           {
                        yylval.uVal = htoi(yytext);
                        return TOK_UINTNUM;
                    }

{INFO_LINES}        { updateLineFileInfo(); }       

{COMMENTS}          { }

{WHITE_SPACES}      { }

"\n"                { yylinenum++; }
 
 /**************** Unrecognized character ==> error ****************/

.                   { return TOK_SYNTAX_ERROR; }

%%
